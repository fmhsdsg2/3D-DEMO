<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <title>3D医工交互批注系统</title>
    <script type="module" src="https://ajax.googleapis.com/ajax/libs/model-viewer/3.3.0/model-viewer.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; font-family: sans-serif; background: #f0f2f5; }
        
        /* 1. 3D视图区域 */
        #viewer-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
        model-viewer { width: 100%; height: 100%; }

        /* 2. 组分控制面板 (左侧) */
        #parts-control {
            position: absolute; top: 20px; left: 20px; z-index: 10;
            background: rgba(255, 255, 255, 0.9); padding: 10px;
            border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            max-height: 50vh; overflow-y: auto;
        }
        .toggle-btn {
            display: block; margin-bottom: 8px; padding: 5px 10px;
            border: 1px solid #007bff; background: #e7f1ff; color: #007bff;
            border-radius: 4px; font-size: 12px; cursor: pointer; width: 100%;
        }
        .toggle-btn.active { background: #007bff; color: white; }

        /* 3. 底部操作栏 */
        #bottom-bar {
            position: absolute; bottom: 20px; left: 0; width: 100%;
            display: flex; justify-content: center; gap: 20px; z-index: 10;
        }
        .action-btn {
            padding: 10px 20px; border-radius: 30px; border: none;
            background: #333; color: white; font-weight: bold;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3); cursor: pointer;
        }

        /* 4. 批注画板层 (默认隐藏) */
        #annotation-layer {
            display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.8); z-index: 999;
            flex-direction: column; align-items: center; justify-content: center;
        }
        #canvas-container { position: relative; border: 2px solid white; box-shadow: 0 0 20px rgba(0,0,0,0.5); }
        canvas { display: block; background: #fff; touch-action: none; }
        #tools-bar { margin-top: 10px; display: flex; gap: 10px; }
    </style>
</head>
<body>

    <div id="viewer-container">
        <model-viewer 
            id="mv"
            src="https://test-med-eng.oss-cn-shenzhen.aliyuncs.com/index.html?Expires=1765382920&OSSAccessKeyId=TMP.3KrqSZ8VRU2e2LEXPxTAGBhDzhyfhbiApESfr55grxMygBWXGKwfCHiqFM1nzSViENeJoA3PuodsbTNF9262WSMUmrZjzF&Signature=ouqbRgkCVtTvAcx6TB9FtNqwQx4%3D" 
            camera-controls 
            shadow-intensity="1"
            touch-action="pan-y">
        </model-viewer>
    </div>

    <div id="parts-control">
        <div style="font-weight:bold; margin-bottom:5px; font-size:14px;">显示/隐藏组分</div>
        <div id="material-list"></div>
    </div>

    <div id="bottom-bar">
        <button class="action-btn" onclick="startAnnotation()">✏️ 截图并批注</button>
    </div>

    <div id="annotation-layer">
        <div style="color:white; margin-bottom:10px;">请在图中圈出问题，长按图片保存</div>
        <div id="canvas-container">
            <canvas id="paintCanvas"></canvas>
        </div>
        <div id="tools-bar">
            <button class="action-btn" style="background:#d9534f" onclick="clearCanvas()">清空</button>
            <button class="action-btn" style="background:#5bc0de" onclick="finishAnnotation()">❌ 关闭</button>
        </div>
    </div>

<script>
        const modelViewer = document.querySelector("#mv");
        const materialListDiv = document.getElementById('material-list');
        
        // --- 修正版：自动识别材质并生成开关 ---
        modelViewer.addEventListener("load", () => {
            const materials = modelViewer.model.materials;
            
            materials.forEach((mat, index) => {
                // 1. 【关键修改】先备份原本的颜色！
                // 我们给材质对象加一个自定义属性 'originalColor' 来存它刚加载时的颜色
                mat.originalColor = [...mat.pbrMetallicRoughness.baseColorFactor];

                // 创建按钮
                const btn = document.createElement('button');
                btn.className = 'toggle-btn active';
                // 显示材质名字 (如果Blender没命名，就显示Part X)
                btn.innerText = mat.name || `Part ${index + 1}`;
                
                // 点击事件：切换透明度
                btn.onclick = () => {
                    // 判断当前按钮是不是灰色的（隐藏状态）
                    const isHidden = btn.classList.contains('hidden');
                    
                    if (!isHidden) {
                        // --- 动作：去隐藏 ---
                        // 设为透明
                        mat.pbrMetallicRoughness.setBaseColorFactor([0, 0, 0, 0]);
                        // 开启混合模式（允许透明）
                        mat.setAlphaMode('BLEND');
                        
                        // 按钮变灰
                        btn.classList.add('hidden');
                        btn.classList.remove('active');
                        btn.style.opacity = '0.5';
                    } else {
                        // --- 动作：去显示 ---
                        // 【关键修改】恢复成我们备份的颜色，而不是白色
                        mat.pbrMetallicRoughness.setBaseColorFactor(mat.originalColor);
                        
                        // 恢复不透明模式 (让渲染更清晰，除非它本来就是半透明的)
                        // 如果你的血管本身需要半透明，可以把这行注释掉
                        mat.setAlphaMode('OPAQUE');
                        
                        // 按钮变亮
                        btn.classList.remove('hidden');
                        btn.classList.add('active');
                        btn.style.opacity = '1';
                    }
                };
                materialListDiv.appendChild(btn);
            });
        });

        // --- 下面是截图批注逻辑 (保持不变) ---
        const annotationLayer = document.getElementById('annotation-layer');
        const canvas = document.getElementById('paintCanvas');
        const ctx = canvas.getContext('2d');
        let isPainting = false;

        async function startAnnotation() {
            const blob = await modelViewer.toBlob({mimeType: 'image/jpeg', qualityArgument: 0.9});
            const url = URL.createObjectURL(blob);
            
            const img = new Image();
            img.onload = () => {
                const maxWidth = window.innerWidth * 0.9;
                const scale = maxWidth / img.width;
                canvas.width = img.width * scale;
                canvas.height = img.height * scale;
                
                ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                ctx.strokeStyle = "red";
                ctx.lineWidth = 3;
                ctx.lineCap = "round";
                
                annotationLayer.style.display = 'flex';
                document.getElementById('bottom-bar').style.display = 'none';
                document.getElementById('parts-control').style.display = 'none';
            };
            img.src = url;
        }

        function getPos(e) {
            const rect = canvas.getBoundingClientRect();
            const x = (e.touches ? e.touches[0].clientX : e.clientX) - rect.left;
            const y = (e.touches ? e.touches[0].clientY : e.clientY) - rect.top;
            return {x, y};
        }

        ['mousedown', 'touchstart'].forEach(ev => {
            canvas.addEventListener(ev, (e) => {
                isPainting = true;
                const pos = getPos(e);
                ctx.beginPath();
                ctx.moveTo(pos.x, pos.y);
                e.preventDefault(); 
            });
        });

        ['mousemove', 'touchmove'].forEach(ev => {
            canvas.addEventListener(ev, (e) => {
                if (!isPainting) return;
                const pos = getPos(e);
                ctx.lineTo(pos.x, pos.y);
                ctx.stroke();
                e.preventDefault();
            });
        });

        ['mouseup', 'touchend'].forEach(ev => {
            canvas.addEventListener(ev, () => {
                isPainting = false;
            });
        });

        function clearCanvas() {
            startAnnotation(); 
        }

        function finishAnnotation() {
            annotationLayer.style.display = 'none';
            document.getElementById('bottom-bar').style.display = 'flex';
            document.getElementById('parts-control').style.display = 'block';
        }
    </script>
</body>
</html>